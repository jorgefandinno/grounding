% ----------------------------------------------------------------------
\begin{frame}{Propagation of facts}
  \bigskip
  \begin{itemize}
    \item Simplifications are performed \alert{on-the-fly}\\
      (rules are printed immediately but not stored in \gringo)
    \smallskip
    \item Maintain a set of \alert{fact atoms}
    \smallskip
    \item Remove facts from positive body
    \smallskip
    \item Discard rules with negative literals over a fact
    \smallskip
    \item Discard rules whenever the head is a fact
    \smallskip
    \item Gather new facts whenever a rule body is empty
  \end{itemize}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}[fragile]{Propagation of facts}{Hamiltonian cycle}
  \bigskip
  \begin{SemiVerbatim}{.9}
...
path(a,b) :- not omit(a,b)\only<1>{, \alert{edge(a,b)}}.
...
reach(a)\only<1>{ :- \alert{start(a)}}. {\only<2->{\color{comment}\% reach(a) is added as fact}}
\visible<3->{
...

\only<4>{\sout}{{:- node(a), not \alert{reach(a)}}.} {\only<4->{\color{comment}\% rule is discarded}}
...}
\end{SemiVerbatim}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}{Propagation of negative literals}
  \bigskip
  \begin{itemize}
  \item \alert{Non-recursive negative literals} not in the current base can be\\ removed from rule bodies
    \smallskip
  \item \alert{Stratified} logic programs are \alert{completely evaluated} during grounding
    \smallskip
  \item Consider the instance where node \texttt{d} is not reachable
  \end{itemize}
  \bigskip
  \begin{center}
    \Graph[draw=none]
  \end{center}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}[fragile,shrink]{Propagation of negative literals}{Hamiltonian cycle}
  \begin{columns}
    \begin{column}{0.45\textwidth}
    \begin{minipage}{.4\textwidth}\small
      \begin{semiverbatim}
path(a,b) :- not omit(a,b).
path(a,c) :- not omit(a,c).
path(b,c) :- not omit(b,c).
path(c,a) :- not omit(c,a).
path(d,a) :- not omit(d,a).
...
\alert{reach(a)}.
\alert{reach(b)} :- path(a,b).
\alert{reach(c)} :- path(a,c).
\alert{reach(c)} :- path(b,c), reach(b).
...
\mbox{{\color{comment}\% reach(X) is not recursive and reach(d)\({}\not\in{}A\)}}
:- not reach(b).
:- not reach(c).
:- \only<1>{not \alert{reach(d)}}. \color{comment}\% \alt<2>{inconsistency detected during grounding}{remove not reach(d) from body}
      \end{semiverbatim}
    \end{minipage}
    \end{column}
    \begin{column}[t]{0.45\textwidth}
      \centering
      \Graph[draw=none]
    \end{column}
  \end{columns}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}{Ignored language features}
  \bigskip
  \begin{itemize}
    \item grounding algorithms for normal logic programs\\(with integrity constraints)
    \item language features not covered here
      \begin{itemize}
        \item (recursive) aggregates
        \item conditional literals
        \item optimization statements
        \item disjunctions
        \item arithmetic functions
        \item syntactic sugar to write more compact encodings
        \item safety of \(=\) relation (for aggregates and terms)
        \item python/lua integration
          \begin{itemize}
            \item external functions
            \item control over grounding and solving
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}
% ----------------------------------------------------------------------
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:

% ----------------------------------------------------------------------
\begin{frame}{Safe body order}
  \bigskip
  \begin{itemize}
  \item Given safe rule \(r\), the tuple \((b_1, \dots, b_n)\) is a \alert{safe body order} if
    \begin{itemize}\normalsize
    \item \(\{ b_1 ,\dots , b_n \} = \body{r} \)
      \smallskip
    \item the body \(\{b_1, \dots, b_i\}\) is safe for each \(i\)
    \end{itemize}
    \bigskip
  \item<2-> \structure{Example} \ Given rule `\texttt{:- node(X), not reach(X).}'
    \begin{itemize}\normalsize
    \item \((\texttt{node(X)}, \texttt{not reach(X)})\) is a safe body order
      \smallskip
    \item \((\texttt{not reach(X)}, \texttt{node(X)})\) is not a safe body order
    \end{itemize}
  \end{itemize}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}{Matching body literals}
  \begin{itemize}
  \item \(\match{\sigma,b}{F,D}\) is the set of \alert{all matches for literal} \(b\)
    \begin{itemize}
    \item \(\sigma\) is a substitution
    \item \(F\) are facts (set of ground atoms)
    \item \(D\) is the domain (set of ground atoms)
    \item \(\sigma' \in \match{\sigma,b}{F,D}\) if
      \begin{itemize}\small
      \item \(\sigma \subseteq \sigma'\) and \(\vars{b} \subseteq \vars{\sigma'} \subseteq \vars{b} \cup \vars{\sigma}\),
      \item \(b\sigma'\) holds if \(b\) is a comparison literal,
      \item \(b\sigma' \in D\) if \(b\) is an atom, and
      \item \(a\sigma' \not\in F\) if \(b\) is a symbolic literal of form \(\texttt{not}\ a\)
      \end{itemize}
    \end{itemize}
    \medskip
  \item<2-> \structure{Example} \ consider body \ `\(\texttt{p(X)},\texttt{q(X,Y)},\texttt{not r(Y)}\)'
    \begin{itemize}
    \item \(F = \{\mathtt{r(3)}\}\) and \(D = \{\mathtt{p(1)}, \mathtt{q(1,2)}, \mathtt{q(1,3)}, \mathtt{r(3)}\}\)
    \item \(\match{\emptyset, \texttt{p(X)}}{F,D} = \{ \{ \mathtt{X} \mapsto 1 \} \}\)
    \item \(\match{\{\mathtt{X} \mapsto 1\}, \texttt{q(X,Y)}}{F,D} = \{ \{ \mathtt{X} \mapsto 1, \mathtt{Y} \mapsto 2 \}, \{ \mathtt{X} \mapsto 1, \mathtt{Y} \mapsto 3 \} \}\)
    \item \(\match{\{\mathtt{X} \mapsto 1, \mathtt{Y} \mapsto 2 \}, \texttt{not r(Y)}}{F,D} = \{ \{ \mathtt{X} \mapsto 1, \mathtt{Y} \mapsto 2 \} \}\)
    \item \(\match{\{\mathtt{X} \mapsto 1, \mathtt{Y} \mapsto 3 \}, \texttt{not r(Y)}}{F,D} = \emptyset\)
    \end{itemize}
  \end{itemize}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}{Rule grounding by backtracking}
    \EmphAlgo{1}{
      \Fn{\(\GroundBacktrack_{r,R,D}(\sigma, F, (b_1,\dots,b_n))\)}{
        \eIf{\(n=0\)}{
          \(\Let~H = \head{r\sigma}\)\;
          \(\phantom{\Let~}B = \pbody{r\sigma} \setminus F \cup {}\)\;
          \(\phantom{\Let~B = {}} \{ \texttt{not }a\sigma \mid a \in \nbody{r} \setminus R, a \in D \} \cup {}\)\;
          \(\phantom{\Let~B = {}} \{ \texttt{not }a\sigma \mid a \in \nbody{r} \cap R \}\)\;
          \lIf{\(B = \emptyset\)}{ \(F \leftarrow F \cup H\) }
          \Return{\((\{ H \leftarrow B \mid \neglits{B} \cap F = \emptyset, H \cap F = \emptyset\}, F)\)}\;
% \nbody{r\sigma} \cap F = \emptyset, H \cap F = \emptyset\}, F)\)}\;
        }{
          \(G \leftarrow \emptyset\)\;
          \ForEach{\(\sigma' \in \match{\sigma,b_1}{F,D}\)}{
            \((G,F) \leftarrow (G,F) \sqcup \GroundBacktrack_{r,R,D}(\sigma', F, (b_2,\dots,b_n))\)\;
          }
          \Return{\((G,F)\)}\;
        }
      }
    }
\end{frame}
% ----------------------------------------------------------------------
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
